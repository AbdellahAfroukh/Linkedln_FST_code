"""
Malware detection service for file uploads.
Uses magic bytes validation and dangerous extension blocking.
Pure Python implementation - no external C libraries required.
"""
from pathlib import Path
from typing import Tuple

# Magic bytes (file signatures) for different file types
MAGIC_BYTES = {
    # Images
    b'\xFF\xD8\xFF': ['.jpg', '.jpeg'],           # JPEG
    b'\x89PNG\r\n\x1a\n': ['.png'],               # PNG
    b'GIF87a': ['.gif'],                           # GIF87
    b'GIF89a': ['.gif'],                           # GIF89
    b'RIFF': ['.webp', '.wav'],                    # WebP/WAV (check further)
    b'BM': ['.bmp'],                               # BMP
    b'II*\x00': ['.tiff', '.tif'],                 # TIFF (little-endian)
    b'MM\x00*': ['.tiff', '.tif'],                 # TIFF (big-endian)
    
    # Documents
    b'%PDF': ['.pdf'],                             # PDF
    b'PK\x03\x04': ['.zip', '.docx', '.xlsx', '.pptx'],  # ZIP-based (Office 2007+)
    b'\xD0\xCF\x11\xE0\xA1\xB1\x1A\xE1': ['.doc', '.xls', '.ppt'],  # MS Office (old format)
    
    # Archives (blocked but detected)
    b'Rar!\x1a\x07': ['.rar'],                     # RAR
    b'7z\xBC\xAF\x27\x1C': ['.7z'],               # 7-Zip
    
    # Executables (should be blocked)
    b'MZ': ['.exe', '.dll'],                       # Windows executables
    b'\x7FELF': ['.elf', '.so'],                   # Linux executables
    b'\xCA\xFE\xBA\xBE': ['.class'],              # Java class
}

# Dangerous extensions that should be blocked
DANGEROUS_EXTENSIONS = {
    '.exe', '.bat', '.cmd', '.com', '.scr', '.vbs', '.js', '.jar',  # Executables
    '.dll', '.sys', '.msi', '.app', '.dmg', '.deb', '.rpm',         # System files
    '.sh', '.bash', '.zsh', '.ps1', '.psc1', '.psd1', '.psm1',      # Scripts
    '.zip', '.rar', '.7z', '.tar', '.gz',                            # Archives (optional)
    '.iso', '.img', '.vhd', '.vmdk',                                 # Disk images
    '.pif', '.lnk', '.scr', '.vb',                                   # Windows shortcuts/scripts
}

# File size limits (in bytes)
FILE_SIZE_LIMITS = {
    'image': 10 * 1024 * 1024,      # 10 MB for images
    'document': 50 * 1024 * 1024,   # 50 MB for documents
}

async def detect_malware(file_path: Path, file_type: str = 'document') -> Tuple[bool, str]:
    """
    Comprehensive malware detection for uploaded files.
    
    Args:
        file_path: Path to the uploaded file
        file_type: Type of file ('image' or 'document')
    
    Returns:
        Tuple[bool, str]: (is_malware, reason)
        - is_malware: True if file is suspicious/malware, False if safe
        - reason: Description of why the file was flagged
    
    Raises:
        Exception: If file doesn't exist or can't be read
    """
    
    if not file_path.exists():
        return True, "File does not exist"
    
    # Check 1: File size validation
    file_size = file_path.stat().st_size
    size_limit = FILE_SIZE_LIMITS.get(file_type, 50 * 1024 * 1024)
    if file_size > size_limit:
        return True, f"File size exceeds limit ({file_size / (1024*1024):.2f}MB > {size_limit / (1024*1024):.2f}MB)"
    
    if file_size == 0:
        return True, "File is empty"
    
    # Check 2: Extension validation
    file_ext = file_path.suffix.lower()
    if file_ext in DANGEROUS_EXTENSIONS:
        return True, f"Dangerous file type: {file_ext}"
    
    # Check 3: Magic bytes validation (file signature verification)
    try:
        magic_check = await validate_magic_bytes(file_path)
        if not magic_check[0]:
            return True, magic_check[1]
    except Exception as e:
        # If magic bytes check fails, try to continue with other checks
        print(f"Magic bytes check failed: {e}")
    
    # All checks passed
    return False, "File passed malware detection"


async def validate_magic_bytes(file_path: Path) -> Tuple[bool, str]:
    """
    Validate file signature (magic bytes) to ensure file type matches extension.
    Pure Python implementation without external dependencies.
    
    Returns:
        Tuple[bool, str]: (is_safe, reason)
    """
    try:
        with open(file_path, 'rb') as f:
            header = f.read(32)  # Read first 32 bytes for better detection
        
        if not header or len(header) < 4:
            return False, "Cannot read file header or file too small"
        
        file_ext = file_path.suffix.lower()
        
        # Special handling for SVG (text-based)
        if file_ext == '.svg':
            try:
                # SVG should start with XML declaration or <svg
                header_text = header[:100].decode('utf-8', errors='ignore')
                if '<?xml' in header_text or '<svg' in header_text:
                    return True, "SVG validated"
            except:
                pass
        
        # Check magic bytes against known signatures
        detected_types = []
        for magic_sig, expected_exts in MAGIC_BYTES.items():
            if header.startswith(magic_sig):
                detected_types.extend(expected_exts)
        
        if not detected_types:
            # No magic bytes detected - might be plain text
            if file_ext in ['.txt', '.csv']:
                # Plain text files don't have magic bytes
                return True, "Plain text file validated"
            # Unknown signature but not dangerous
            return True, f"Unknown file signature, extension: {file_ext}"
        
        # Check if detected type matches file extension
        if file_ext in detected_types:
            return True, f"Magic bytes validated: {file_ext}"
        
        # Check for common compatible formats
        # Office documents are ZIP-based
        if file_ext in ['.docx', '.xlsx', '.pptx'] and '.zip' in detected_types:
            return True, f"Office document validated: {file_ext}"
        
        # JPEG can be .jpg or .jpeg
        if file_ext in ['.jpg', '.jpeg'] and ('.jpg' in detected_types or '.jpeg' in detected_types):
            return True, "JPEG validated"
        
        # TIFF variants
        if file_ext in ['.tiff', '.tif'] and ('.tiff' in detected_types or '.tif' in detected_types):
            return True, "TIFF validated"
        
        # File signature doesn't match extension - potential threat
        return False, f"File signature ({', '.join(detected_types)}) does not match extension ({file_ext})"
    
    except Exception as e:
        # Don't block on validation errors, just log
        print(f"Magic bytes validation error: {e}")
        return True, f"Validation skipped due to error"


def get_file_type_category(file_ext: str) -> str:
    """Determine if file is image or document."""
    IMAGES = {'.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp', '.tiff'}
    DOCUMENTS = {'.pdf', '.doc', '.docx', '.txt', '.xls', '.xlsx', '.ppt', '.pptx'}
    
    ext = file_ext.lower()
    if ext in IMAGES:
        return 'image'
    elif ext in DOCUMENTS:
        return 'document'
    else:
        return 'document'  # Default to document (more restrictive)
